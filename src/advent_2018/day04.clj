(ns advent-2018.day04
  (:require [clojure.java.io :as io]
            [clojure.string :as str]))

;;; https://adventofcode.com/2018/day/4

;; Read all the lines in the given file. Return a list of lines. "doall" is
;; needed to fully-realize the lazyseq before the filehandle is closed.
(defn- read-lines [file]
  (with-open [rdr (io/reader file)]
    (doall (line-seq rdr))))

;; This is the regexp that will be used to pick-apart the lines of input:
(def ^:private line-re #"\[((\d+)-(\d+)-(\d+) (\d\d):(\d\d))\] (.*)")

;; Convert one line of input to an event structure:
(defn- line-to-event [line]
  (let [m         (re-find line-re line)
        [type id] (str/split (m 7) #" ")
        event     {:timestamp (m 1)
                   :year      (m 2)
                   :month     (m 3)
                   :day       (m 4)
                   :hour      (m 5)
                   :minute    (m 6)}]
    (cond
      (= type "wakes") (assoc event :type "WAKE")
      (= type "falls") (assoc event :type "SLEEP")
      (= type "Guard") (assoc event
                              :type  "START"
                              :guard (Integer/parseInt
                                      (apply str (rest id))))
      :else            (throw (Exception. (str "Unknown line type: " type))))))

;; Wrapper to convert all lines to a seq of event structures:
(defn- lines-to-events [lines]
  (map line-to-event lines))

;; Utility to set all elements of a vector from idx to the end to the given
;; value:
(defn- set-from [v idx val]
  (vec (map #(if (>= % idx) val (v %)) (range 0 60))))

;; Register the start of a shift. For this, we push a new vector (of all 0's)
;; onto the given guard's "schedule". The other two register-* functions will
;; operate on the first element of this list.
(defn- register-start [struct event]
  (let [guard   (:guard event)
        current (get struct guard ())]
    (assoc struct guard (cons (vec (repeat 60 0)) current))))

;; Register that the guard has gone to sleep at the minute given in the event.
;; Do this by setting everything from the given minute to the end to a value of
;; 1.
(defn- register-sleep [struct event guard]
  (let [sched (get struct guard)
        shift (first sched)]
    (assoc struct guard
           (cons (set-from shift (Integer/parseInt (:minute event)) 1)
                 (rest sched)))))

;; Register that the guard has woken up at the minute given in the event. Do
;; this by setting everything from the given minute to the end to a value of 0.
(defn- register-wake [struct event guard]
  (let [sched (get struct guard)
        shift (first sched)]
    (assoc struct guard
           (cons (set-from shift (Integer/parseInt (:minute event)) 0)
                 (rest sched)))))

;; Take the sequence of events that were generated by the lines of input, and
;; turn them into the overall structure of guards and their schedules.
(defn- events-to-struct [events]
  (loop [struct           {}
         guard            nil
         [event & events] events]
    (cond
      (nil? event) struct
      (= "START" (:type event)) (recur (register-start struct event)
                                       (:guard event)
                                       events)
      (= "SLEEP" (:type event)) (recur (register-sleep struct event guard)
                                       guard
                                       events)
      (= "WAKE"  (:type event)) (recur (register-wake struct event guard)
                                       guard
                                       events))))

;;; Problem 1

;; Get the candidate guard by sorting the list of guards by the total time
;; spent asleep during shifts.
(defn- get-candidate [struct]
  (let [candidates (keys struct)
        sortthis   (map #(hash-map :guard %
                                   :total (apply + (flatten (struct %))))
                        candidates)]
    (:guard (last (sort #(compare (:total %1) (:total %2)) sortthis)))))

;; Having chosen a candidate guard, get the minute that they're asleep the
;; most-often. Do this by adding all the shift-vectors together and picking the
;; minute-index with the highest value.
(defn- get-minute [sched]
  (let [minvec  (vec (apply map + sched))
        sortmin (map #(hash-map :index %, :value (minvec %)) (range 60))]
    (:index (last (sort #(compare (:value %1) (:value %2)) sortmin)))))

;; Return the candidate-guard's ID and minute-index as a list:
(defn- get-candidate-and-minute-1 [struct]
  (let [candidate (get-candidate struct)
        minute    (get-minute (struct candidate))]
    (list candidate minute)))

;; The data in "file" is the (unsorted) list of observations of the guard's
;; habits while on duty. Convert it from a sorted list of lines to a structure
;; that can be used to determine which guard sleeps the most, and which minute
;; he's most-often asleep.
(defn p01 [file]
  (->> file
       (read-lines)
       (sort)
       (lines-to-events)
       (events-to-struct)
       (get-candidate-and-minute-1)
       (apply *)))

;;; Problem 2

;; Find the most-sleeped minute for the given guard.
(defn- get-best-minute [struct guard]
  (let [sched   (struct guard)
        minvec  (vec (apply map + sched))
        sortmin (map #(hash-map :index %, :value (minvec %), :guard guard)
                     (range 60))]
    (last (sort #(compare (:value %1) (:value %2)) sortmin))))

;; Find the guard who is most-often asleep on a consistent minute.
(defn- get-candidate-and-minute-2 [struct]
  (let [candidates (map #(get-best-minute struct %) (keys struct))
        pick       (last (sort #(compare (:value %1) (:value %2)) candidates))]
    (list (:guard pick) (:index pick))))

;; The data in "file" is the (unsorted) list of observations of the guard's
;; habits while on duty. Convert it from a sorted list of lines to a structure
;; that can be used to determine which guard is most often asleep at a given
;; minute, and which one.
(defn p02 [file]
  (->> file
       (read-lines)
       (sort)
       (lines-to-events)
       (events-to-struct)
       (get-candidate-and-minute-2)
       (apply *)))
